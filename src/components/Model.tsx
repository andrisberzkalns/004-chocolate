/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.2.13 .\pergale_dark.glb --types 
*/

import * as THREE from "three";
import React, { useEffect, useReducer, useRef, useState } from "react";
import { useGLTF, useAnimations, useScroll } from "@react-three/drei";
import { GLTF } from "three-stdlib";
import { useFrame } from "@react-three/fiber";
import * as misc from "maath/misc";

type GLTFResult = GLTF & {
  nodes: {
    Cube: THREE.Mesh;
    Plane: THREE.Mesh;
    Cube001: THREE.Mesh;
  };
  materials: {
    Material: THREE.MeshStandardMaterial;
    ["Material.001"]: THREE.MeshStandardMaterial;
  };
};

enum ChocolateTypes {
  pergale_dark = "pergale_dark",
  pergale_cranberries = "pergale_cranberries",
  pergale_forestberries = "pergale_forestberries",
}

const ChocolateArray = Object.values(ChocolateTypes);
const MODEL_COUNT = ChocolateArray.length;

type ModelsProps = {
  offset: number;
  cameraRef: React.RefObject<THREE.Camera>;
};

type useModelOutput = {
  groupRef: React.RefObject<THREE.Group>;
  nodes: GLTFResult["nodes"];
  actions: {
    [x: string]: THREE.AnimationAction | null;
  };
  materials: GLTFResult["materials"];
};

const useModel = (source: string): useModelOutput => {
  const { nodes, materials, animations } = useGLTF(source) as GLTFResult;
  const group = useRef<THREE.Group>(null);
  const animation = useAnimations<THREE.AnimationClip>(animations, group);

  if (animation.clips.length < 0) {
    throw new Error("No animation clips found");
  }

  return {
    groupRef: group,
    nodes: nodes,
    materials: materials,
    actions: animation.actions,
  };
};

const Models: React.FC<ModelsProps> = ({ offset, cameraRef }) => {
  const [bg, setBg] = useState("cyan" as string);
  const {
    groupRef: pergale_dark_group,
    nodes: pergale_dark_nodes,
    materials: pergale_dark_material,
    actions: pergale_dark_actions,
  } = useModel("/assets/pergale_dark.glb");
  const {
    groupRef: pergale_cranberries_group,
    nodes: pergale_cranberries_nodes,
    materials: pergale_cranberries_material,
    actions: pergale_cranberries_actions,
  } = useModel("/assets/pergale_cranberries.glb");
  const {
    groupRef: pergale_forestberries_group,
    nodes: pergale_forestberries_nodes,
    materials: pergale_forestberries_material,
    actions: pergale_forestberries_actions,
  } = useModel("/assets/pergale_forestberries.glb");

  const { animations: cameraAnimations } = useGLTF(
    "/assets/camera_1.glb",
  ) as GLTFResult;
  const { actions: cameraActions } = useAnimations<THREE.AnimationClip>(
    cameraAnimations,
    cameraRef,
  );

  const { animations: cameraAnimations_2 } = useGLTF(
    "/assets/camera_2.glb",
  ) as GLTFResult;
  const { actions: cameraActions_2 } = useAnimations<THREE.AnimationClip>(
    cameraAnimations_2,
    cameraRef,
  );

  const { animations: cameraAnimations_3 } = useGLTF(
    "/assets/camera_3.glb",
  ) as GLTFResult;
  const { actions: cameraActions_3 } = useAnimations<THREE.AnimationClip>(
    cameraAnimations_3,
    cameraRef,
  );

  const [offsets, setOffsets] = useState<{ [key in ChocolateTypes]: number }>({
    pergale_dark: 0,
    pergale_cranberries: 0,
    pergale_forestberries: 0,
  });

  // useFrame((state, delta) => {

  // });

  useEffect(() => {
    setOffsets((current) => {
      const newOffsets = structuredClone(current);
      ChocolateArray.forEach((key, index) => {
        const min_value = index / MODEL_COUNT;
        const max_value = (index + 1) / MODEL_COUNT;
        const value =
          misc.clamp(offset, min_value, max_value) * MODEL_COUNT - index;
        newOffsets[key] = value;
      });
      return newOffsets;
    });
  }, [offset]);

  useEffect(() => {
    cameraActions["CameraAction"]!.play().paused = true;
    cameraActions_2["CameraAction"]!.play().paused = true;
    cameraActions_3["CameraAction"]!.play().paused = true;
  }, []);

  useFrame((state, delta) => {
    const cameraAction = cameraActions["CameraAction"];
    const cameraAction_2 = cameraActions_2["CameraAction"];
    const cameraAction_3 = cameraActions_3["CameraAction"];
    if (!cameraAction) return;
    if (!cameraAction_2) return;
    if (!cameraAction_3) return;

    let finalColor = new THREE.Color();

    if (offsets.pergale_dark > 0 && offsets.pergale_dark < 1) {
      cameraAction_2.time =
        cameraAction_2.getClip().duration * offsets.pergale_dark;
      finalColor.lerpColors(
        new THREE.Color(bg),
        new THREE.Color("steelblue"),
        0.05,
      );
      setBg(finalColor.getStyle());
    } else if (
      offsets.pergale_cranberries > 0 &&
      offsets.pergale_cranberries < 1
    ) {
      cameraAction.time =
        cameraAction.getClip().duration * offsets.pergale_cranberries;
      finalColor.lerpColors(
        new THREE.Color(bg),
        new THREE.Color("crimson"),
        0.05,
      );
      setBg(finalColor.getStyle());
    } else if (
      offsets.pergale_forestberries > 0 &&
      offsets.pergale_forestberries < 1
    ) {
      cameraAction_3.time =
        cameraAction_3.getClip().duration * offsets.pergale_forestberries;

      finalColor.lerpColors(
        new THREE.Color(bg),
        new THREE.Color("purple"),
        0.05,
      );
      setBg(finalColor.getStyle());
    }
  });

  return (
    <>
      <Model
        groupRef={pergale_dark_group}
        geometry={pergale_dark_nodes.Cube001.geometry}
        material={pergale_dark_material["Material.001"]}
        action={pergale_dark_actions["Cube.001Action.001"]!}
        offset={offsets[ChocolateTypes.pergale_dark] || 0}
      />
      <Model
        groupRef={pergale_cranberries_group}
        geometry={pergale_cranberries_nodes.Cube001.geometry}
        material={pergale_cranberries_material["Material.001"]}
        action={pergale_cranberries_actions["Cube.001Action.001"]!}
        offset={offsets[ChocolateTypes.pergale_cranberries] || 0}
      />
      <Model
        groupRef={pergale_forestberries_group}
        geometry={pergale_forestberries_nodes.Cube001.geometry}
        material={pergale_forestberries_material["Material.001"]}
        action={pergale_forestberries_actions["Cube.001Action.001"]!}
        offset={offsets[ChocolateTypes.pergale_forestberries] || 0}
      />
      <mesh
        position={[0, -4.7, 0]}
        rotation={[-Math.PI / 12, 0, 0]}
        receiveShadow
      >
        <planeGeometry args={[100, 100]} />
        <meshStandardMaterial color={bg} />
      </mesh>
    </>
  );
};

type ModelProps = {
  offset: number;
  action: THREE.AnimationAction;
  geometry: THREE.BufferGeometry;
  material: THREE.Material;
  groupProps?: JSX.IntrinsicElements["group"];
  groupRef: React.RefObject<THREE.Group>;
};

export function Model(props: ModelProps) {
  const { offset, action, material, geometry, groupRef } = props;
  useEffect(() => {
    if (action) action.play().paused = true;
  }, [action]);
  useFrame((state, delta) => {
    if (!action) return;
    action.time = THREE.MathUtils.damp(
      action.time,
      action.getClip().duration * offset,
      100,
      delta,
    );
  });

  return (
    <group
      ref={groupRef}
      {...props.groupProps}
      dispose={null}
      visible={offset > 0 && offset < 1}
    >
      <group name="Scene" scale={0.7}>
        <mesh
          castShadow
          name="Cube001"
          geometry={geometry}
          material={material}
          rotation={[Math.PI / 2, 0, 0]}
          scale={[0.985, 1.032, 2.083]}
        />
      </group>
    </group>
  );
}

useGLTF.preload("/assets/pergale_dark.glb");
useGLTF.preload("/assets/pergale_cranberries.glb");
useGLTF.preload("/assets/pergale_forestberries.glb");
useGLTF.preload("/assets/camera_1.glb");
useGLTF.preload("/assets/camera_2.glb");
useGLTF.preload("/assets/camera_3.glb");

export default Models;
